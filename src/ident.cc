/*
 *   ident.cc by Puiok, Jan 7 2000, for TRE (The River's Edge)
 *      jioxuejea@hotmail.com
 * 
 *
 *  Request for an ident using id_create_request.
 *  void id_create_request(link_data* link, int port, struct sockaddr_in* addr, REPORTER);
 *    port - mudport
 *    link - link_data*
 *    addr - should be filled appropriately
 *    REPORTER - see below
 *  
 *  Receive the ident with subsquent calls to id_check_request.  If the ident is 
 *  resolved or an error occurs, REPORTER is called.
 *  void id_check_request(link_data* link);
 *    link - link_data*
 *  
 *  Cleanup with id_kill_request, when the link is going to be closed/deleted.
 *  void id_kill_request(link_data* link);
 *    link - link_data*
 *
 *
 *    Identification Protocol is defined in RFC 1413
 */

#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <signal.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <errno.h>
#include "define.h"
#include "struct.h"

/*
 *  void (*reporter)(int type, char *token, char *charset, char *userid, link_data *link)
 *  
 *  Is called when an errors occurs or when the ident is resolved, and can be from anywhere
 *  within the three id_xxx_request functions.
 *  
 *  Type can be used to determine the report: 1=Ident resolved, 2=General error, 3=Network
 *  error, 4=Ident error.  Type 5 is cleanup.
 *  
 *  Incase the of three errors types, charset and userid are not used.  Token will hold the
 *  description of the error and can be anything from "pipe failed", "connection failed" to
 *  "HIDDEN-USER".  (The last one generated by the remote server. (type=4))
 *  
 *  In the case of type=1, token will hold the name of the remote operating system (UNIX,
 *  OTHER,..), userid the userid, and charset the name of the character set userid is in.
 *  An unnamed charset is default to US-ASCII.  Refer to "Assigned Numbers" RFC 1340 for
 *  a complete listing.
 *  
 *  Link is same as the link passed in.
 *  
 *  What the REPORTER should do:
 *    - Allocate memory and fill in link->ident.userid and link->ident.token
 *    - Make the info broadcast where appropriate
 *    - Log to file where necessary
 *    -   Handle non US-ASCII charsets... (if one wishes)
 *
 *  What the REPORT should NOT do:
 *    - Change any of link->ident apart from the two mentioned above
 *  
 *  Type=5: Cleanup: Free the memory from link->ident.userid and link->ident.token,
 *                   this is called at the end of id_kill_request.
 */

#define IDENT_PORT 113
#define TIMEOUT 10

#define MAX_RETRY 7
#define MAX_RESULT_LENGTH 1000

#define FALSE 0
#define TRUE 1

bool   wait_and_retry        (link_data*, int);

int    parse_ident            (char *, char *, char *, char *);
int    request_ident          (char *, unsigned long, int, int);


void id_create_request(link_data *link, int mudport, struct sockaddr_in *servaddr,
  void (*reporter)(int, char *, char *, char *, link_data *))
{
  int rv, pfds[2];
  pid_t pid;
  char ident_result[MAX_RESULT_LENGTH];
  struct timeval t_init, t_now;
  
  if(link->ident.ipid > 0 || link->ident.retry > 0)
    return;
  
  if(mudport != 0)
    link->ident.port = mudport;
  if(servaddr != NULL)
  {
    link->ident.host   = servaddr->sin_addr.s_addr;
    link->ident.r_port = ntohs(servaddr->sin_port);
  }
  if(reporter != NULL)
    link->ident.reporter = reporter;
  else if(link->ident.reporter == NULL)
  {
    bug("id_create_request: NULL reporter");
    return;
  }
  
  gettimeofday(&t_init, 0);
  
  if(pipe(pfds) < 0)
  {
    if(errno == EMFILE)
    {
      wait_and_retry(link, 5);
      return;
    }
    else
    {
      (link->ident.reporter)(2, "pipe failed", "", "", link);
      return;
    }
  }
  
  if((pid = fork()) < 0)
  {
    close(pfds[0]);
    close(pfds[1]);
    
    if(errno == EAGAIN || errno == ENOMEM)
    {
      wait_and_retry(link, 7);
      return;
    }
    else
    {
      (link->ident.reporter)(2, "fork failed", "", "", link);
      return;
    }
  }
  else if(pid == 0)
  {
    close(pfds[0]);
    rv = request_ident(ident_result, link->ident.host, link->ident.r_port, link->ident.port);
    if(write(pfds[1], ident_result, strlen(ident_result) + 1) < 0)
      rv = 3;
    close(pfds[1]);
    if(rv == 2)
    {
      gettimeofday(&t_now, 0);
      if((t_now.tv_sec - t_init.tv_sec) >= TIMEOUT)
        rv = 1;
    }
    _exit(rv);
  }
  else
  {
    close(pfds[1]);
    link->ident.ipid = pid;
    link->ident.ifd  = pfds[0];
  }
}

void id_check_request(link_data* link)
{
  int rv;
  char ident_result[MAX_RESULT_LENGTH];
  
  if(link->ident.ipid == 0)
    return;
  
  if(link->ident.ipid > 0)
  {
    switch(waitpid(link->ident.ipid, &rv, WNOHANG))
    {
      case -1:
          link->ident.ipid  = -1;
          link->ident.ifd   = -1;
          if(errno == ECHILD)
            wait_and_retry(link, 7);
          else if(errno == EINVAL)
            bug("id_check_request: waitpid: EINVAL");
        break;
        
      case 0:
        break;
        
      default:
        /* Perform the magic */
        read(link->ident.ifd, ident_result, MAX_RESULT_LENGTH);
        close(link->ident.ifd);
        
        link->ident.ipid  = -1;
        link->ident.ifd   = -1;
        if(rv == 0)
        {
          char token[64], charset[64], userid[512];
          if((rv = parse_ident(ident_result, token, charset, userid)) == 1)
          {
            (link->ident.reporter)(1, token, charset, userid, link);
          }
          else if(rv == 2)
          {
            (link->ident.reporter)(4, token, "", "", link);
          }
          else 
          {
            (link->ident.reporter)(4, "UNKNOWN-ERROR", "", "", link);
          }
        }
        else if(rv == 2 && wait_and_retry(link, 5))
        {
          break;
        }
        else
        {
          (link->ident.reporter)(3, ident_result, "", "", link);
        }
        link->ident.ipid = 0;
        break;
    }
  }
  else if(link->ident.retry > 0)
  {
    struct timeval t_now;
    
    gettimeofday(&t_now, 0);
    if(t_now.tv_sec > link->ident.wait)
    {
      link->ident.retry *= -1;
      id_create_request(link, 0, NULL, NULL); /* NULL, reuse values */
    }
  }
}

void id_kill_request(link_data* link)
{
  int err, rv;
  char ident_result[MAX_RESULT_LENGTH];
  
  if(link->ident.ipid > 0)
  {
    if((err = waitpid(link->ident.ipid, &rv, WNOHANG)) > 0)
    {
      char token[64], charset[64], userid[512];
      read(link->ident.ifd, ident_result, MAX_RESULT_LENGTH);

      if((rv = parse_ident(ident_result, token, charset, userid)) == 1)
      {
        (link->ident.reporter)(1, token, charset, userid, link);
      }
      else if(rv == 2)
      {
        (link->ident.reporter)(4, token, "", "", link);
      }
      else 
      {
        (link->ident.reporter)(4, "UNKNOWN-ERROR", "", "", link);
      }
    }
    else if(err == 0 || (err == -1 && errno != ECHILD))
    {
      kill(link->ident.ipid, SIGKILL);
      waitpid(link->ident.ipid, &rv, WNOHANG);
      (link->ident.reporter)(3, "player left before resolve", "", "", link);
    }
    close(link->ident.ifd);
    link->ident.ipid = 0;
    link->ident.ifd  = -1;
  }
  link->ident.retry   = 0;
  
  (link->ident.reporter)(5, "", "", "", link);
}

bool wait_and_retry(link_data* link, int wait_sec)
{
  struct timeval t_now;
  
  if(abs(link->ident.retry) >= MAX_RETRY)
    return FALSE;
  
  gettimeofday(&t_now, 0);
  
  link->ident.wait  = t_now.tv_sec + wait_sec;
  link->ident.retry = abs(link->ident.retry) + 1;
  
  return TRUE;
}

char *strip_ident_spaces(char *text)
{
  for(; *text == ' ' || *text == '\t'; text++ ) ;

  if(*text == '\0')
    return NULL;

  return text;
}

char *next_ident_token(char *text)
{
  for(; *text != ':'; text++)
    if(*text == '\0')
      return NULL;
  
  if(*(++text) == '\0')
    return NULL;
  
  return strip_ident_spaces(text);
}

#define IDENT_USERID "USERID"
#define IDENT_ERROR "ERROR"

int parse_ident(char *reply_text, char *rtoken, char *rcharset, char *ruserid)
{
  char *charptr;
  char token[65];
  
  if(rtoken != NULL)
    *rtoken = '\0';
  if(rcharset != NULL)
    *rcharset = '\0';
  if(ruserid != NULL)
    *ruserid = '\0';
  
  if((reply_text = next_ident_token(reply_text)) == NULL)
    return -1;
    
  if(!strncmp(reply_text, IDENT_USERID, strlen(IDENT_USERID)))
  {
    char userid[513], charset[65];
    
    reply_text += strlen(IDENT_USERID);
    
    if((reply_text = next_ident_token(reply_text)) == NULL)
      return -1;
      
    for(charptr = token; *reply_text != ' ' && *reply_text != ',' &&
      *reply_text != ':'; reply_text++, charptr++)
    {
      if(*reply_text == '\0')
        break;
      
      if(charptr - token < sizeof(token))
        *charptr = *reply_text;
      else
        break;
    }
    
    if(charptr - token < sizeof(token))
      *charptr = '\0';
    else
      token[sizeof(token) - 1] = '\0';

    if(rtoken != NULL)
      strcpy(rtoken, token);
    
    for(; *reply_text != ' ' && *reply_text != ',' && *reply_text != ':'; reply_text++)
      if(*reply_text == '\0')
        return 1;
    
    if((reply_text = strip_ident_spaces(reply_text)) == NULL)
      return 1;
    
    if(*reply_text == ',')
    {
      if((reply_text = strip_ident_spaces(++reply_text)) == NULL)
        return 1;
      
      for(charptr = charset; *reply_text != ' ' &&
        *reply_text != ':'; reply_text++, charptr++)
      {
        if(*reply_text == '\0')
          break;

        if(charptr - charset < sizeof(charset))
          *charptr = *reply_text;
        else
          break;
      }
      
      if(charptr - charset < sizeof(charset))
        *charptr = '\0';
      else
        charset[sizeof(charset) - 1] = '\0';

      if(rcharset != NULL)
        strcpy(rcharset, charset);
      
      for(; *reply_text != ' ' && *reply_text != ':'; reply_text++)
        if(*reply_text == '\0')
          return 1;
      
      if((reply_text = strip_ident_spaces(reply_text)) == NULL)
        return 1;
    }
    
    if(*reply_text != ':')
    {
      bug("parse_ident: ':' expected, (this should not happen)");
      return -186549090;
    }
    
    if((reply_text = strip_ident_spaces(++reply_text)) == NULL)
      return 1;
    
    for(charptr = userid; *reply_text != '\0'; reply_text++, charptr++)
    {
      if(charptr - userid < sizeof(userid))
        *charptr = *reply_text;
      else
        break;
    }
    
    if(charptr - userid < sizeof(userid))
      *charptr = '\0';
    else
      userid[sizeof(userid) - 1] = '\0';

    if(ruserid != NULL)
      strcpy(ruserid, userid);

    return 1;
  }
  else if(!strncmp(reply_text, IDENT_ERROR, strlen(IDENT_ERROR)))
  {
    reply_text += strlen(IDENT_ERROR);
    
    if((reply_text = next_ident_token(reply_text)) == NULL)
      return -1;
      
    for(charptr = token; *reply_text != ' ' && *reply_text != '\0';
      reply_text++, charptr++)
    {
      if(charptr - token < sizeof(token))
        *charptr = *reply_text;
      else
        break;
    }
    
    if(charptr - token < sizeof(token))
      *charptr = '\0';
    else
      token[sizeof(token) - 1] = '\0';

    if(rtoken != NULL)
      strcpy(rtoken, token);

    return 2;
  }

  return -1;
}

int request_ident(char *result, unsigned long host, int remote_port, int local_port)
{
  int  sd, err;
  int  option;
  struct sockaddr_in servaddr;
  int  datalen;
  char databuf[512];

  *result = '\0';

  if((sd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
  {
    strcpy(result, "socket creation failed");
    return errno == EMFILE ? 2 : 1;
  }
  
  option = 1;
  if(setsockopt(sd, SOL_SOCKET, SO_REUSEADDR, (char *) &option, sizeof(option)) < 0) ;
  
  bzero((char *) &servaddr, sizeof(servaddr));
  servaddr.sin_family      = AF_INET;
  servaddr.sin_port        = htons(IDENT_PORT);
  servaddr.sin_addr.s_addr = host;
  
  if((err = connect(sd, (struct sockaddr *) &servaddr, sizeof(servaddr))) < 0)
    strcpy(result, "could not connect");

  if(!(err < 0))
  {
    sprintf(databuf, "%d,%d\n", remote_port, local_port );
    if((err = send(sd, &databuf, strlen(databuf), 0)) < 0)
      strcpy(result, "send request failed");
  }
  
  if(!(err < 0))
  {
    struct timeval t_init, t_now;
    int complete = FALSE, i;
    
    gettimeofday(&t_init, 0);

    while(!complete)
    {
      if((datalen = recv(sd, &databuf, sizeof(databuf), 0)) < 0)
      {
        if(errno == EPIPE || errno == ENETRESET || errno == ENOTCONN)
          strcpy(result, ":ERROR:UNKNOWN-ERROR");
        else
        {
          strcpy(result, "receive failed");
          err = -1;
        }
        break;
      }

      if(datalen > 0)
      {
        for(i = 0; i < datalen; i++)
          if(databuf[i] == '\n' || databuf[i] == '\r')
          {
            datalen = i;
            complete = TRUE;
            break;
          }
        if(strlen(result) + datalen < MAX_RESULT_LENGTH)
        {
          result[strlen(result) + datalen] = '\0';
          bcopy(&databuf[0], &result[strlen(result)], datalen);
        }
        else
        {
          sprintf(result, "data exceed %d chars", MAX_RESULT_LENGTH);
          err = -1;
          break;
        }
      }
      else
      {
        gettimeofday(&t_now, 0);
        if((t_now.tv_sec - t_init.tv_sec) >= TIMEOUT)
        {
          sprintf(result, "timedout %d seconds", TIMEOUT);
          err = -1;
          break;
        }
      }
    }
  }

  close(sd);
  
  return (err == -1 ? 1 : (err == -2 ? 2 : 0));
}
